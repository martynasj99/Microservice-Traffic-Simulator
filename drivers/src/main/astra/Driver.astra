import mams.HALConverter;
import modules.TypeConversion;
import modules.LogicConversion;

agent Driver extends mams.PassiveMAMSAgent {
    module System system;
    module Console console;
    module HALConverter hal;
    module Functions F;
    module TypeConversion tc;
    module ObjectAccess oa;
    module LogicConversion logic;

    initial !init();

    types mams {
        formula service_uri(string);
        formula vehicle(int);
    }

    initial service_uri("http://localhost:8081/vehicles");

    rule +!init(){
        //system.trace(true);
        MAMSAgent::!init();
        MAMSAgent::!created("base");
        +vehicle(tc.stringToInt(system.name()));
        PassiveMAMSAgent::!itemResource("notifications", "EnvironmentState");
        console.println("Hello world, " + system.name());
    }

    rule $cartago.signal(string source_artifact_name, updatedObject(EnvironmentState notifications)) {
        cartago.println("name: " + notifications);

        //!nextAction(notifications);


        int id = oa.getInt(notifications, "id");
        string type = oa.getString(notifications, "type");

        int vehicleSpeed = oa.getInt(notifications, "vehicleSpeed");
        int streetSpeed = oa.getInt(notifications, "streetSpeed");
        boolean trafficLightStatus = oa.getBoolean(notifications, "trafficLightStatus");

        int intersectionCurrentCapacity = oa.getInt(notifications, "intersectionCurrentCapacity");
        int intersectionMaxCapacity = oa.getInt(notifications, "intersectionMaxCapacity");

        boolean atIntersection = oa.getBoolean(notifications, "atIntersection");
        boolean atLastCell = oa.getBoolean(notifications, "atLastCell");
        boolean hasArrived = oa.getBoolean(notifications, "hasArrived");
        boolean hasEndNode = oa.getBoolean(notifications, "hasEndNode");

        boolean vehicleAhead = oa.getBoolean(notifications, "vehicleAhead");
        boolean obstacleInVision = oa.getBoolean(notifications, "obstacleInVision");
        boolean obstacleAhead = oa.getBoolean(notifications, "obstacleAhead");

        boolean canLeave = oa.getBoolean(notifications, "canLeave");

        //boolean s = (hasArrived == true);
        //cartago.println("ex: " + intersectionCurrentCapacity < intersectionMaxCapacity);

        string action = "wait";

      /*  if(hasArrived == true) {
            action = "wait";
        }
        else if(atIntersection == true & canLeave == true){
            action = "leave";
        }
        else if( atLastCell == true & vehicleSpeed == 1 & trafficLightStatus == true & intersectionCurrentCapacity < intersectionMaxCapacity ){
            action = "enter";
        }*/
        if(hasArrived == true | atLastCell == true){

        }
        /*if( vehicleSpeed > 0 & vehicleAhead == true | obstacleAhead == true & vehicleSpeed > 1 | atLastCell == true & trafficLightStatus == false & intersectionCurrentCapacity >= intersectionMaxCapacity | vehicleSpeed < 2  ){
            action = "decelerate";
        }*/
    /*    else if( vehicleSpeed == 0 & ((atLastCell == true & (trafficLightStatus == true & (intersectionCurrentCapacity < intersectionMaxCapacity)))
            & vehicleSpeed == 0) | (atLastCell == false  & obstacleAhead == false) | (vehicleSpeed == 0 & atLastCell == false & vehicleAhead == false)
            & vehicleSpeed < streetSpeed & obstacleInVision == false ) action = "accelerate";
        else if(atIntersection == false & vehicleSpeed > 0) action = "move";
        else action = "wait";*/

        cartago.println("action: " + action);
        !act(action);

    }


/*    rule +!nextAction(EnvironmentState s) : oa.getBoolean(s, "hasArrived") == true {
        cartago.println("action: wait");
        !act("wait");
    }

    rule +!nextAction(EnvironmentState s) : oa.getBoolean(s, "atIntersection") == true & oa.getBoolean(s, "canLeave") == true {
        cartago.println("action: leave");
        !act("leave");
    }

    rule +!nextAction(EnvironmentState s) : oa.getInt(s, "vehicleSpeed") >= 1 & oa.getBoolean(s, "vehicleAhead") == true | (oa.getBoolean(s, "obstacleAhead") == true & oa.getInt(s, "vehicleSpeed") > 1) | (oa.getBoolean(s, "atLastCell") == true & (oa.getBoolean(s, "trafficLightStatus") == false & oa.getInt(s, "intersectionCurrentCapacity") >= oa.getInt(s, "intersectionMaxCapacity")))  | oa.getInt(s, "vehicleSpeed") < 2  {
        cartago.println("action: decelerate");
        !act("decelerate");
    }*/

    rule +!act(string action): service_uri(string uri) & vehicle(int id){
       cartago.println("PUT: [ id: " + id + " uri: " + uri);
       !put(uri+"/"+id+"/action", "{\"type\":\""+action+"\"}", int code, string content);
    }

    rule +$cartago.property(string name, funct f) {
    }


    /*   private boolean canEnterIntersection(EnvironmentState state){
            return oa.getBoolean(state, "trafficLightStatus") == true
                    & (oa.getInt(state, "intersectionCurrentCapacity") < oa.getInt(state, "intersectionMaxCapacity"));
        }
        private boolean shouldSlowDown(EnvironmentState state){
            return oa.getBoolean(state, "vehicleAhead") == true
                | (oa.getBoolean(state, "obstacleAhead") == true & oa.getInt(state, "vehicleSpeed") > 1)
                | (oa.getBoolean(state, "atLastCell") == true
                & ( (oa.getBoolean(state, "trafficLightStatus") == true
                & (oa.getInt(state, "intersectionCurrentCapacity") < oa.getInt(state, "intersectionMaxCapacity"))) | state.getVehicleSpeed() > 1 ) == false);
        }

        private boolean canAccelerate(EnvironmentState state){
            return ((oa.getBoolean(state, "atLastCell") == true
            & (oa.getBoolean(state, "trafficLightStatus") == true & (oa.getInt(state, "intersectionCurrentCapacity") < oa.getInt(state, "intersectionMaxCapacity"))))
            & oa.getInt(state, "vehicleSpeed") == 0)
                    || (oa.getBoolean(state, "atLastCell") == false  & oa.getBoolean(state, "obstacleAhead") == false) | (oa.getInt(state, "vehicleSpeed") == 0 && oa.getBoolean(state, "atLastCell") == false & oa.getBoolean(state, "vehicleAhead") == false))
                    && oa.getInt(state, "vehicleSpeed") < oa.getInt(state, "streetSpeed") && oa.getBoolean(state, "obstacleInVision") == false ;
        }*/

}