import mams.HALConverter;
import modules.TypeConversion;

agent Driver extends mams.PassiveMAMSAgent {
    module System system;
    module Console console;
    module HALConverter hal;
    module Functions F;
    module TypeConversion tc;
    module ObjectAccess oa;

    initial !init();

    types mams {
        formula service_uri(string);
        formula vehicle(int);
    }

    initial service_uri("http://localhost:8081/vehicles");

    rule +!init(){
        //system.trace(true);
        MAMSAgent::!init();
        MAMSAgent::!created("base");
        +vehicle(tc.stringToInt(system.name()));
        PassiveMAMSAgent::!itemResource("state", "EnvironmentState");
        console.println("Hello world, " + system.name());
    }

    rule $cartago.signal(string source_artifact_name, updatedObject(EnvironmentState state)) {
        cartago.println("name: " + state);

        boolean hasArrived = oa.getBoolean(state, "hasArrived");
        boolean atIntersection = oa.getBoolean(state, "atIntersection");
        boolean canLeave = oa.getBoolean(state, "canLeave");
        boolean atLastCell = oa.getBoolean(state, "atLastCell");
        boolean trafficLightStatus = oa.getBoolean(state, "trafficLightStatus");
        boolean vehicleAhead = oa.getBoolean(state, "vehicleAhead");
        boolean obstacleAhead = oa.getBoolean(state, "obstacleAhead");
        boolean obstacleInVision = oa.getBoolean(state, "obstacleInVision");
        int vehicleSpeed = oa.getInt(state, "vehicleSpeed");
        int intersectionCurrentCapacity = oa.getInt(state, "intersectionCurrentCapacity");
        int intersectionMaxCapacity = oa.getInt(state, "intersectionMaxCapacity");
        int streetSpeed = oa.getInt(state, "streetSpeed");

        string action = "wait";

        if(hasArrived == true ) {
            action = "wait";
        }
        else if(atIntersection == true & canLeave == true){
            action = "leave";
        }
        else if( atLastCell == true & vehicleSpeed == 1 & trafficLightStatus == true & intersectionCurrentCapacity < intersectionMaxCapacity ){
            action = "enter";
        }
        else if( (vehicleSpeed > 0 & (vehicleAhead == true | obstacleAhead == true) & (vehicleSpeed > 1 | atLastCell == true) & trafficLightStatus == false & (intersectionCurrentCapacity >= intersectionMaxCapacity  | vehicleSpeed < 2) ) ){
            action = "decelerate";
        }
        /*else if( vehicleSpeed == 0 & ((atLastCell == true & (trafficLightStatus == true & (intersectionCurrentCapacity < intersectionMaxCapacity)))
            & vehicleSpeed == 0) | (atLastCell == false  & obstacleAhead == false) | (vehicleSpeed == 0 & atLastCell == false & vehicleAhead == false)
            & vehicleSpeed < streetSpeed & obstacleInVision == false ) action = "accelerate";
        else if(atIntersection == false & vehicleSpeed > 0) action = "move";*/
        //else action = "wait";

        cartago.println("action: " + action);
        !act(action);
    }

    rule +!act(string action): service_uri(string uri) & vehicle(int id){
       cartago.println("PUT: [ id: " + id + " uri: " + uri);
       !put(uri+"/"+id+"/action", "{\"type\":\""+action+"\"}", int code, string content);
    }

    rule +$cartago.property(string name, id(int t)) {
    }
    rule +$cartago.property(string name, time(int t)) {
    }
    rule +$cartago.property(string name, vehicleSpeed(int t)) {
    }
    rule +$cartago.property(string name, streetSpeed(int t)) {
    }
    rule +$cartago.property(string name, trafficLightStatus(boolean t)) {
    }
    rule +$cartago.property(string name, intersectionCurrentCapacity(int t)) {
    }
    rule +$cartago.property(string name, intersectionMaxCapacity(int t)) {
    }
    rule +$cartago.property(string name, atIntersection(boolean t)) {
    }
    rule +$cartago.property(string name, atLastCell(boolean t)) {
    }
    rule +$cartago.property(string name, hasArrived(boolean t)) {
    }
    rule +$cartago.property(string name, hasEndNode(boolean t)) {
    }
    rule +$cartago.property(string name, vehicleAhead(boolean t)) {
    }
    rule +$cartago.property(string name, obstacleInVision(boolean t)) {
    }
    rule +$cartago.property(string name, obstacleAhead(boolean t)) {
    }
    rule +$cartago.property(string name, canLeave(boolean t)) {
    }


    /*   private boolean canEnterIntersection(EnvironmentState state){
            return oa.getBoolean(state, "trafficLightStatus") == true
                    & (oa.getInt(state, "intersectionCurrentCapacity") < oa.getInt(state, "intersectionMaxCapacity"));
        }
        private boolean shouldSlowDown(EnvironmentState state){
            return oa.getBoolean(state, "vehicleAhead") == true
                | (oa.getBoolean(state, "obstacleAhead") == true & oa.getInt(state, "vehicleSpeed") > 1)
                | (oa.getBoolean(state, "atLastCell") == true
                & ( (oa.getBoolean(state, "trafficLightStatus") == true
                & (oa.getInt(state, "intersectionCurrentCapacity") < oa.getInt(state, "intersectionMaxCapacity"))) | state.getVehicleSpeed() > 1 ) == false);
        }

        private boolean canAccelerate(EnvironmentState state){
            return ((oa.getBoolean(state, "atLastCell") == true
            & (oa.getBoolean(state, "trafficLightStatus") == true & (oa.getInt(state, "intersectionCurrentCapacity") < oa.getInt(state, "intersectionMaxCapacity"))))
            & oa.getInt(state, "vehicleSpeed") == 0)
                    || (oa.getBoolean(state, "atLastCell") == false  & oa.getBoolean(state, "obstacleAhead") == false) | (oa.getInt(state, "vehicleSpeed") == 0 && oa.getBoolean(state, "atLastCell") == false & oa.getBoolean(state, "vehicleAhead") == false))
                    && oa.getInt(state, "vehicleSpeed") < oa.getInt(state, "streetSpeed") && oa.getBoolean(state, "obstacleInVision") == false ;
        }*/

}