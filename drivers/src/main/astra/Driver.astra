import mams.HALConverter;
import modules.TypeConversion;

agent Driver extends mams.PassiveMAMSAgent {
    module System system;
    module Console console;
    module HALConverter hal;
    module Functions F;
    module TypeConversion tc;
    module ObjectAccess oa;

    initial !init();

    types mams {
        formula service_uri(string);
        formula vehicle(int);
    }

    initial service_uri("http://localhost:8081/vehicles");

    rule +!init(){
        //system.trace(true);
        MAMSAgent::!init();
        MAMSAgent::!created("base");
        +vehicle(tc.stringToInt(system.name()));
        PassiveMAMSAgent::!itemResource("notifications", "EnvironmentState");
        console.println("Hello world, " + system.name());
    }

    rule $cartago.signal(string source_artifact_name, updatedObject(EnvironmentState notifications)) {
        cartago.println("name: " + notifications);

        int id = oa.getInt(notifications, "id");
        string type = oa.getString(notifications, "type");

        int vehicleSpeed = oa.getInt(notifications, "vehicleSpeed");
        int streetSpeed = oa.getInt(notifications, "streetSpeed");
        boolean trafficLightStatus = oa.getBoolean(notifications, "trafficLightStatus");

        int intersectionCurrentCapacity = oa.getInt(notifications, "intersectionCurrentCapacity");
        int intersectionMaxCapacity = oa.getInt(notifications, "intersectionMaxCapacity");

        boolean atIntersection = oa.getBoolean(notifications, "atIntersection");
        boolean atLastCell = oa.getBoolean(notifications, "atLastCell");
        boolean hasArrived = oa.getBoolean(notifications, "hasArrived");
        boolean hasEndNode = oa.getBoolean(notifications, "hasEndNode");

        boolean vehicleAhead = oa.getBoolean(notifications, "vehicleAhead");
        boolean obstacleInVision = oa.getBoolean(notifications, "obstacleInVision");
        boolean obstacleAhead = oa.getBoolean(notifications, "obstacleAhead");

        boolean canLeave = oa.getBoolean(notifications, "canLeave");

        cartago.println("id: " + id);
        cartago.println("type: " + type);
        cartago.println("vehicleSpeed: " + vehicleSpeed);
        cartago.println("streetSpeed: " + streetSpeed);
        cartago.println("trafficLightStatus: " + trafficLightStatus);
        cartago.println("intersectionCurrentCapacity: " + intersectionCurrentCapacity);
        cartago.println("intersectionMaxCapacity: " + intersectionMaxCapacity);
        cartago.println("atIntersection: " + atIntersection);
        cartago.println("atLastCell: " + atLastCell);
        cartago.println("hasArrived: " + hasArrived);
        cartago.println("hasEndNode: " + hasEndNode);
        cartago.println("vehicleAhead: " + vehicleAhead);
        cartago.println("obstacleInVision: " + obstacleInVision);
        cartago.println("obstacleAhead: " + obstacleAhead);
        cartago.println("canLeave: " + canLeave);

        string action = "wait";

        if(hasArrived == true ) {
            action = "wait";
        }
        else if(atIntersection == true & canLeave == true){
            action = "leave";
        }
        else if( atLastCell == true & vehicleSpeed == 1 & trafficLightStatus == true & intersectionCurrentCapacity < intersectionMaxCapacity ){
            action = "enter";
        }
        else if( (vehicleSpeed > 0 & (vehicleAhead == true | obstacleAhead == true) & (vehicleSpeed > 1 | atLastCell == true) & trafficLightStatus == false & (intersectionCurrentCapacity >= intersectionMaxCapacity  | vehicleSpeed < 2) ) ){
            action = "decelerate";
        }
        else if( vehicleSpeed == 0 & ((atLastCell == true & (trafficLightStatus == true & (intersectionCurrentCapacity < intersectionMaxCapacity)))
            & vehicleSpeed == 0) | (atLastCell == false  & obstacleAhead == false) | (vehicleSpeed == 0 & atLastCell == false & vehicleAhead == false)
            & vehicleSpeed < streetSpeed & obstacleInVision == false ) action = "accelerate";
        else if(atIntersection == false & vehicleSpeed > 0) action = "move";
        else action = "wait";

        cartago.println("action: " + action);
        !act(action);
    }

    rule +!act(string action): service_uri(string uri) & vehicle(int id){
       cartago.println("PUT: [ id: " + id + " uri: " + uri);
       !put(uri+"/"+id+"/action", "{\"type\":\""+action+"\"}", int code, string content);
    }

    rule +$cartago.property(string name, id(int t)) {
    }
    rule +$cartago.property(string name, type(string t)) {
    }
    rule +$cartago.property(string name, vehicleSpeed(int t)) {
    }
    rule +$cartago.property(string name, streetSpeed(int t)) {
    }
    rule +$cartago.property(string name, trafficLightStatus(boolean t)) {
    }
    rule +$cartago.property(string name, intersectionCurrentCapacity(int t)) {
    }
    rule +$cartago.property(string name, intersectionMaxCapacity(int t)) {
    }
    rule +$cartago.property(string name, atIntersection(boolean t)) {
    }
    rule +$cartago.property(string name, atLastCell(boolean t)) {
    }
    rule +$cartago.property(string name, hasArrived(boolean t)) {
    }
    rule +$cartago.property(string name, hasEndNode(boolean t)) {
    }
    rule +$cartago.property(string name, vehicleAhead(boolean t)) {
    }
    rule +$cartago.property(string name, obstacleInVision(boolean t)) {
    }
    rule +$cartago.property(string name, obstacleAhead(boolean t)) {
    }
    rule +$cartago.property(string name, canLeave(boolean t)) {
    }


    /*   private boolean canEnterIntersection(EnvironmentState state){
            return oa.getBoolean(state, "trafficLightStatus") == true
                    & (oa.getInt(state, "intersectionCurrentCapacity") < oa.getInt(state, "intersectionMaxCapacity"));
        }
        private boolean shouldSlowDown(EnvironmentState state){
            return oa.getBoolean(state, "vehicleAhead") == true
                | (oa.getBoolean(state, "obstacleAhead") == true & oa.getInt(state, "vehicleSpeed") > 1)
                | (oa.getBoolean(state, "atLastCell") == true
                & ( (oa.getBoolean(state, "trafficLightStatus") == true
                & (oa.getInt(state, "intersectionCurrentCapacity") < oa.getInt(state, "intersectionMaxCapacity"))) | state.getVehicleSpeed() > 1 ) == false);
        }

        private boolean canAccelerate(EnvironmentState state){
            return ((oa.getBoolean(state, "atLastCell") == true
            & (oa.getBoolean(state, "trafficLightStatus") == true & (oa.getInt(state, "intersectionCurrentCapacity") < oa.getInt(state, "intersectionMaxCapacity"))))
            & oa.getInt(state, "vehicleSpeed") == 0)
                    || (oa.getBoolean(state, "atLastCell") == false  & oa.getBoolean(state, "obstacleAhead") == false) | (oa.getInt(state, "vehicleSpeed") == 0 && oa.getBoolean(state, "atLastCell") == false & oa.getBoolean(state, "vehicleAhead") == false))
                    && oa.getInt(state, "vehicleSpeed") < oa.getInt(state, "streetSpeed") && oa.getBoolean(state, "obstacleInVision") == false ;
        }*/

}